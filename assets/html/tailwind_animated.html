<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Disable all CSS animations/transitions for deterministic frame-based rendering */
    *, *::before, *::after {
      animation-play-state: paused !important;
      transition: none !important;
    }
    ${custom_style}
  </style>
</head>
<body class="bg-white text-gray-800 h-full flex flex-col">
  ${html_body}

  <script>
    // === MulmoCast Animation Helpers ===

    /**
     * Easing functions for non-linear interpolation.
     */
    const Easing = {
      linear: (t) => t,
      easeIn: (t) => t * t,
      easeOut: (t) => 1 - (1 - t) * (1 - t),
      easeInOut: (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
    };

    /**
     * Interpolation with clamping and optional easing.
     *
     * @param {number} value - Current value (typically frame number)
     * @param {Object} opts - { input: { inMin, inMax }, output: { outMin, outMax }, easing?: string | function }
     * @returns {number} Interpolated and clamped value
     *
     * @example
     *   interpolate(frame, { input: { inMin: 0, inMax: 30 }, output: { outMin: 0, outMax: 1 } })
     *   interpolate(frame, { input: { inMin: 0, inMax: 30 }, output: { outMin: 0, outMax: 1 }, easing: 'easeOut' })
     */
    function interpolate(value, opts) {
      const { inMin, inMax } = opts.input;
      const { outMin, outMax } = opts.output;
      if (inMax === inMin) {
        return outMin;
      }
      const easing = !opts.easing ? Easing.linear
        : typeof opts.easing === 'function' ? opts.easing
        : Easing[opts.easing] || Easing.linear;
      const progress = Math.max(0, Math.min(1, (value - inMin) / (inMax - inMin)));
      return outMin + easing(progress) * (outMax - outMin);
    }

    // === MulmoAnimation Helper Class ===

    const TRANSFORM_PROPS = { translateX: 'px', translateY: 'px', scale: '', rotate: 'deg', rotateX: 'deg', rotateY: 'deg', rotateZ: 'deg' };
    const SVG_PROPS = ['r', 'cx', 'cy', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'rx', 'ry',
                       'width', 'height', 'stroke-width', 'stroke-dashoffset', 'stroke-dasharray', 'opacity'];

    function MulmoAnimation() {
      this._entries = [];
    }

    /**
     * Register a property animation on a single element.
     * @param {string} selector - CSS selector (e.g. '#title')
     * @param {Object} props - { opacity: [0, 1], translateY: [30, 0], width: [0, 80, '%'] }
     * @param {Object} opts - { start, end, easing }  (start/end in seconds)
     */
    MulmoAnimation.prototype.animate = function(selector, props, opts) {
      this._entries.push({ kind: 'animate', selector, props, opts: opts || {} });
      return this;
    };

    /**
     * Stagger animation across numbered elements.
     * Selector must contain {i} placeholder (e.g. '#item{i}').
     * @param {string} selector - e.g. '#item{i}'
     * @param {number} count - number of elements (0-indexed)
     * @param {Object} props - same as animate()
     * @param {Object} opts - { start, stagger, duration, easing }
     */
    MulmoAnimation.prototype.stagger = function(selector, count, props, opts) {
      this._entries.push({ kind: 'stagger', selector, count, props, opts: opts || {} });
      return this;
    };

    /**
     * Typewriter effect — reveal text character by character.
     * @param {string} selector - target element selector
     * @param {string} text - full text to reveal
     * @param {Object} opts - { start, end }
     */
    MulmoAnimation.prototype.typewriter = function(selector, text, opts) {
      this._entries.push({ kind: 'typewriter', selector, text, opts: opts || {} });
      return this;
    };

    /**
     * Animated counter — interpolate a number and display with optional prefix/suffix.
     * @param {string} selector - target element selector
     * @param {[number, number]} range - [from, to]
     * @param {Object} opts - { start, end, prefix, suffix, decimals }
     */
    MulmoAnimation.prototype.counter = function(selector, range, opts) {
      this._entries.push({ kind: 'counter', selector, range, opts: opts || {} });
      return this;
    };

    /**
     * Code reveal — show lines of code one by one (line-level typewriter).
     * @param {string} selector - target element selector
     * @param {string[]} lines - array of code lines
     * @param {Object} opts - { start, end }
     */
    MulmoAnimation.prototype.codeReveal = function(selector, lines, opts) {
      this._entries.push({ kind: 'codeReveal', selector, lines, opts: opts || {} });
      return this;
    };

    /**
     * Blink — periodic show/hide toggle (e.g. cursor blinking).
     * @param {string} selector - target element selector
     * @param {Object} opts - { interval } (half-cycle seconds, default 0.5)
     */
    MulmoAnimation.prototype.blink = function(selector, opts) {
      this._entries.push({ kind: 'blink', selector, opts: opts || {} });
      return this;
    };

    /** Resolve easing name string or function to an easing function */
    MulmoAnimation.prototype._resolveEasing = function(e) {
      if (!e) return Easing.linear;
      if (typeof e === 'function') return e;
      return Easing[e] || Easing.linear;
    };

    /** Apply props to element at a given progress (0-1) with easing */
    MulmoAnimation.prototype._applyProps = function(el, props, progress, easingFn) {
      if (!el) return;
      const transforms = [];
      Object.keys(props).forEach((prop) => {
        const spec = props[prop];
        const from = spec[0], to = spec[1];
        const unit = (spec.length > 2) ? spec[2] : null;
        const val = from + easingFn(progress) * (to - from);

        if (TRANSFORM_PROPS.hasOwnProperty(prop)) {
          const tUnit = unit || TRANSFORM_PROPS[prop];
          transforms.push(prop === 'scale' ? 'scale(' + val + ')' : prop + '(' + val + tUnit + ')');
        } else if (el instanceof SVGElement && SVG_PROPS.indexOf(prop) !== -1) {
          el.setAttribute(prop, val);
        } else if (prop === 'opacity') {
          el.style.opacity = val;
        } else {
          const cssUnit = unit || 'px';
          el.style[prop] = val + cssUnit;
        }
      });
      if (transforms.length > 0) {
        el.style.transform = transforms.join(' ');
      }
    };

    /**
     * Update all registered animations for the given frame.
     * @param {number} frame - current frame number
     * @param {number} fps - frames per second
     */
    MulmoAnimation.prototype.update = function(frame, fps) {
      this._entries.forEach((entry) => {
        const opts = entry.opts;
        const easingFn = this._resolveEasing(opts.easing);

        if (entry.kind === 'animate') {
          const startFrame = (opts.start || 0) * fps;
          const endFrame = (opts.end === 'auto' ? window.__MULMO.totalFrames / fps : (opts.end || 0)) * fps;
          const progress = Math.max(0, Math.min(1, endFrame === startFrame ? 1 : (frame - startFrame) / (endFrame - startFrame)));
          const el = document.querySelector(entry.selector);
          this._applyProps(el, entry.props, progress, easingFn);

        } else if (entry.kind === 'stagger') {
          const baseStart = (opts.start || 0) * fps;
          const staggerDelay = (opts.stagger || 0.2) * fps;
          const dur = (opts.duration || 0.5) * fps;
          for (let j = 0; j < entry.count; j++) {
            const sel = entry.selector.replace(/\{i\}/g, j);
            const sEl = document.querySelector(sel);
            const sStart = baseStart + j * staggerDelay;
            const sEnd = sStart + dur;
            const sProgress = Math.max(0, Math.min(1, sEnd === sStart ? 1 : (frame - sStart) / (sEnd - sStart)));
            this._applyProps(sEl, entry.props, sProgress, easingFn);
          }

        } else if (entry.kind === 'typewriter') {
          const twStart = (opts.start || 0) * fps;
          const twEnd = (opts.end === 'auto' ? window.__MULMO.totalFrames / fps : (opts.end || 0)) * fps;
          const twProgress = Math.max(0, Math.min(1, twEnd === twStart ? 1 : (frame - twStart) / (twEnd - twStart)));
          const charCount = Math.floor(twProgress * entry.text.length);
          const twEl = document.querySelector(entry.selector);
          if (twEl) twEl.textContent = entry.text.substring(0, charCount);

        } else if (entry.kind === 'counter') {
          const cStart = (opts.start || 0) * fps;
          const cEnd = (opts.end === 'auto' ? window.__MULMO.totalFrames / fps : (opts.end || 0)) * fps;
          const cProgress = Math.max(0, Math.min(1, cEnd === cStart ? 1 : (frame - cStart) / (cEnd - cStart)));
          const cVal = entry.range[0] + easingFn(cProgress) * (entry.range[1] - entry.range[0]);
          const decimals = opts.decimals || 0;
          const display = (opts.prefix || '') + cVal.toFixed(decimals) + (opts.suffix || '');
          const cEl = document.querySelector(entry.selector);
          if (cEl) cEl.textContent = display;

        } else if (entry.kind === 'codeReveal') {
          const crStart = (opts.start || 0) * fps;
          const crEnd = (opts.end === 'auto' ? window.__MULMO.totalFrames / fps : (opts.end || 0)) * fps;
          const crProgress = Math.max(0, Math.min(1, crEnd === crStart ? 1 : (frame - crStart) / (crEnd - crStart)));
          const lineCount = Math.floor(crProgress * entry.lines.length);
          const crEl = document.querySelector(entry.selector);
          if (crEl) crEl.textContent = entry.lines.slice(0, lineCount).join('\n');

        } else if (entry.kind === 'blink') {
          const interval_s = opts.interval || 0.5;
          const blinkEl = document.querySelector(entry.selector);
          if (blinkEl) {
            const cycle = (frame / fps) / interval_s;
            blinkEl.style.opacity = (Math.floor(cycle) % 2 === 0) ? 1 : 0;
          }
        }
      });
    };

    // === MulmoCast Frame State (updated by Puppeteer per frame) ===
    window.__MULMO = {
      frame: 0,
      totalFrames: ${totalFrames},
      fps: ${fps},
    };
  </script>

  ${user_script}

  <script>
    // Auto-render: if MulmoAnimation is used but render() is not defined, generate it
    if (typeof render !== 'function' && typeof animation !== 'undefined' && animation instanceof MulmoAnimation) {
      window.render = function(frame, totalFrames, fps) { animation.update(frame, fps); };
    }

    // Initial render (frame 0)
    if (typeof render === 'function') {
      const result = render(0, window.__MULMO.totalFrames, window.__MULMO.fps);
      if (result && typeof result.then === 'function') {
        result.catch(console.error);
      }
    }
  </script>
</body>
</html>
